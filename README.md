# Software System Modeling

## Introduction

### Target

- Provide a formal language to model and design software systems 
- Offer ways to properly communicate design to peers

Note: this course will not teach you what is the best approach to solve a specific issue, but only a way to quickly analise solutions, see pottential implementation issues, as well as build effective documentation for it. 

### UML

UML is the standard for modeling software systems and is part of a most of the currently used applications for documenting design. 

UML is a language, which means it comes with a syntax for how to draw as well as semantics which give light on how they should be interpreted and how two different elements relate. This also means that UML is not a process of designing solutions, but merely a way of communicating it without getting into implementation language specifics. 

The functional units of the UML language are the diagrams, each type of which with different "words" (graphic elements) and use cases. 

UML models (one or more diagrams) provide a view of the system. In order to fully understand a system, just like in real-life aspects, several views might be needed to get the full picture, as well as different levels of detail, depending on the target audience. The aim of the course is to go through the most used diagram types, understanding their usage and limitations so that later you can choose the appropriate one when needed. 

### Types of diagrams

- Structural diagrams
  - Class diagrams
  - Component diagrams
  - Package diagrams
  - Deployment diagrams
- Behavioral diagrams
  - Activity
  - Sequence diagrams
  - State machine diagrams
  - Use case diagrams

### General rules

- Almost everything is optional in UML
- Never aim for completeness 
- UML might require organizational or team specific interpretation
- It can always be extended

## Modeling

Modeling is meant to capture ideas, relationships, decisions and requirements in a well-defined notation. The exact process and result of modeling can be freely interpreted by each individual, but for a model to be efficient, it needs to convey the same implementation ideas or requirements to it's indented readers. 
